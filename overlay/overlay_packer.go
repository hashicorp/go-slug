package slugoverlay

import (
	"errors"
	"fmt"
	"hash/crc32"
	"io"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/hashicorp/go-slug"
)

// ErrNoBase is the error returns if PackOverlay is called without first setting
// a base directory using Rebase
var ErrNoBase = errors.New("no base directory has been set for the overlay filesystem")

// OverlayPacker is a slug Packer that only includes files that were changed or modified
// after establishing a base path. It also preserves file deletions when unpacked
// into a destination directory that contain those files by deleting them again.
// In this manner, OverlayPacker can be used to generate an overlay filesystem
// archive that can preserve file system operations on an identical directory that
// it was based on. This can be useful when processing a large filesystem and
// storing only what has changed in order to re-create the changed filesystem at
// a later time.
type OverlayPacker struct {
	packer slug.Packer

	// The path that the OverlayPacker was based on, following a call to Rebase
	basePath string

	// A set of relative paths with a crc32 checksum calculation on the contents for each
	checksums checksums
}

const (
	// The size of the buffer to use when calculating the checksum of each file
	bufferSize = 8192

	// The file extension of the tombstone file markers
	tombstoneExt = ".tombstone"

	// The file contents of the tombstone file markers
	tombstoneContents = "This file is automatically generated by go-slug to indicate that a file of the same name should be deleted after unpacking."
)

// Stores crc32 checksum data about each file/dir in the base directory. The key
// of each file is the relative path of the file from base directory.
type checksums map[string]overlayFileMeta

type overlayFileMeta struct {
	isDir bool
	crc32 uint32
}

// NewOverlayPacker creates a new OverlayPacker, based on a specified path,
// using the specified PackerOptions. If basePath is empty, the overlay base will not
// be established and an error will be raised if you do not call Rebase at
// some point before calling PackOverlay.
func NewOverlayPacker(basePath string, options ...slug.PackerOption) (*OverlayPacker, error) {
	p := &OverlayPacker{
		packer: slug.Packer{},
	}
	for _, o := range options {
		err := o(&p.packer)
		if err != nil {
			return nil, err
		}
	}

	slug.InclusionPredicate(func(relpath string, info os.FileInfo) bool {
		if p.basePath == "" {
			// No rebase was performed
			return true
		}

		if info.IsDir() {
			// No need to include directories in overlay. If a file needs to be included
			// in the overlay, it will return to this predicate function for evaluation
			// and be handled properly below.
			return false
		}

		existing, ok := p.checksums[relpath]
		if !ok {
			// New file
			return true
		}

		cs, err := checksumFile(path.Join(p.basePath, relpath))
		if err != nil {
			// If the file can't be checksummed for some reason, try to include
			// it. If it can't be checksummed it likely can't be read for archiving.
			return true
		}

		// Modified file
		return cs != existing.crc32
	})(&p.packer)

	if len(basePath) != 0 {
		if err := p.Rebase(basePath); err != nil {
			return nil, err
		}
	}

	return p, nil
}

// PackOverlay creates an overlay slug from the base directory and writes the new slug
// to w. Returns metadata about the slug and any errors.
//
// The overlay slug only contains files that were created or modified since calling
// Rebase, as well as metadata about which files were deleted.
func (p OverlayPacker) PackOverlay(w io.Writer) (*slug.Meta, error) {
	if p.basePath == "" {
		return nil, ErrNoBase
	}

	// Examine all original checksums, looking for deleted files and folders
	for name := range p.checksums {
		target := path.Join(p.basePath, name)
		_, err := os.Stat(target)
		if errors.Is(err, os.ErrNotExist) {
			// This is a deleted file, so create a marker for it
			err = os.WriteFile(target+tombstoneExt, []byte(tombstoneContents), 0700)
			if err != nil {
				return nil, fmt.Errorf("failed to write tombstone marker: %w", err)
			}
		}
	}

	return p.packer.Pack(p.basePath, w)
}

// UnpackOverlay is used to read and extract the contents of an overlay slug to the dst
// directory, which is expected to be populated. It behaves exactly as Unpack, except it
// also processes .tombstone files, re-deleting files that were deleted following a
// Rebase.
func (p OverlayPacker) UnpackOverlay(r io.Reader, dst string) error {
	if err := p.packer.Unpack(r, dst); err != nil {
		return err
	}

	// Look for tombstone files and delete the corresponding files and tombstones
	return filepath.WalkDir(dst, func(name string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		return p.processTombstone(name)
	})
}

func (p OverlayPacker) processTombstone(filename string) error {
	ext := path.Ext(filename)
	if ext != tombstoneExt {
		return nil
	}
	actual := filename[:len(filename)-len(ext)]
	err := os.Remove(filename)
	if err != nil {
		return fmt.Errorf("failed to remove tombstone file: %s", err)
	}
	err = os.RemoveAll(actual)
	if err != nil {
		return fmt.Errorf("failed to remove file/dir indicated by tombstone file: %s", err)
	}

	return nil
}

// Rebase re-establishes the base of the OverlayPacker. It walks the specified root
// directory recursively, storing a crc32 checksum of each file. This snapshot
// will be used by the PackOverlay method as a basis of comparison when packing the
// created, modified, or deleted files.
func (p *OverlayPacker) Rebase(root string) error {
	stat, err := os.Stat(root)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return err
		}
		return fmt.Errorf("failed to stat rebase target: %w", err)
	}
	if !stat.IsDir() {
		return errors.New("rebase target must be a directory")
	}

	p.basePath = root
	if strings.HasSuffix(p.basePath, string(os.PathSeparator)) {
		p.basePath = p.basePath[:len(p.basePath)-1]
	}

	p.checksums = make(checksums)
	return p.walkBase(p.basePath)
}

func (p *OverlayPacker) walkBase(dir string) error {
	return filepath.WalkDir(dir, func(wdir string, d fs.DirEntry, err error) error {
		if err != nil {
			// An error occurred
			return err
		}

		if dir == wdir {
			// The root directory
			return nil
		}

		// wdir is always prefixed by dir. Drop that from the checksum set key
		key := wdir[len(dir)+1:]
		meta := overlayFileMeta{
			isDir: d.IsDir(),
		}

		if !d.IsDir() {
			meta.crc32, err = checksumFile(wdir)
			if err != nil {
				return err
			}
		}

		p.checksums[key] = meta
		return nil
	})
}

func checksumFile(path string) (uint32, error) {
	table := crc32.MakeTable(crc32.IEEE)
	var checksum uint32

	file, err := os.Open(path)
	if err != nil {
		return checksum, fmt.Errorf("failed to open file for checksum: %w", err)
	}

	buf := make([]byte, bufferSize)
	for {
		n, err := file.Read(buf)
		if n > 0 {
			checksum = crc32.Update(checksum, table, buf[:n])
		}
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			return 0, fmt.Errorf("failed to read file for checksum: %w", err)
		}
	}

	return checksum, nil
}
